{"meta":{"title":"循迹者的日常","subtitle":null,"description":null,"author":"ROY1994","url":"https://roy1994.top"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-07-21T16:21:18.052Z","comments":false,"path":"bangumi/index.html","permalink":"https://roy1994.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-07-21T17:03:03.879Z","comments":false,"path":"about/index.html","permalink":"https://roy1994.top/about/index.html","excerpt":"","text":"_这里是「ROY1994」_ 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-07-21T13:51:03.710Z","comments":true,"path":"comment/index.html","permalink":"https://roy1994.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-07-19T11:06:35.860Z","comments":false,"path":"client/index.html","permalink":"https://roy1994.top/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-07-21T13:51:56.100Z","comments":false,"path":"lab/index.html","permalink":"https://roy1994.top/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-07-21T13:51:29.091Z","comments":false,"path":"donate/index.html","permalink":"https://roy1994.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-07-21T16:03:44.461Z","comments":false,"path":"music/index.html","permalink":"https://roy1994.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-10-01T07:28:13.868Z","comments":true,"path":"links/index.html","permalink":"https://roy1994.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-07-19T11:06:35.861Z","comments":true,"path":"rss/index.html","permalink":"https://roy1994.top/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-07-19T11:06:35.861Z","comments":true,"path":"tags/index.html","permalink":"https://roy1994.top/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-07-19T11:06:35.861Z","comments":false,"path":"video/index.html","permalink":"https://roy1994.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-07-19T11:06:35.861Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://roy1994.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"开始写博客啦!","slug":"开始写博客啦","date":"2022-03-13T05:00:42.000Z","updated":"2022-03-13T13:36:23.716Z","comments":true,"path":"2022/03/13/开始写博客啦/","link":"","permalink":"https://roy1994.top/2022/03/13/开始写博客啦/","excerpt":"","text":"每天摆烂也不是个头,写写博客做个记录好了","categories":[{"name":"生活","slug":"生活","permalink":"https://roy1994.top/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://roy1994.top/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://roy1994.top/categories/生活/"}]},{"title":"位运算","slug":"位运算","date":"2021-07-23T16:50:19.000Z","updated":"2021-12-05T07:04:20.578Z","comments":true,"path":"2021/07/24/位运算/","link":"","permalink":"https://roy1994.top/2021/07/24/位运算/","excerpt":"","text":"1.&amp;如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。 注：下面都用8位的 unsigned char 来做例子。 &amp;简单举例：11&amp;3 = 3 00001011 &amp; 00000011 = 00000011 = 3 &amp;比较实用的例子：我们经常要用的是否被2整除，一般都写成 if(n % 2 == 0) 可以换成 if((n&amp;1) == 0) 2.|如果两个相应的二进制位只要有一个是1，结果就是1；否则为0。 | 简单例子：11 | 3 = 11 00001011 | 00000011 = 00001011 = 11 | 比较实用的例子可以用一个unsigned int 来存储多个布尔值。比如一个文件有读权限，写权限，执行权限。看起来要记录3个布尔值。我们可以用一个unsigned int也可以完成任务。 一个数r来表示读权限，它只更改个位来记录读权限的布尔值 00000001 (表示有读权限) 00000000 (表示没有读权限) 一个数w表示写权限，它只用二进制的倒数第二位来记录布尔值 00000010 (表示有写权限) 00000000 (表示没有写权限) 一个数x表示执行权限，它只用倒数第三位来记录布尔值 00000100 (表示有执行权限) 00000000 (表示没有执行权限) 那么一个文件同时没有3种权限就是 ~r | ~ w | ~ x 即为 00000000，就是0 只有读的权限就是 r | ~w | ~x 即为 00000001，就是1 只有写的权限就是 ~r | w | ~x 即为 00000010，就是2 一个文件同时有3种权限就是 r | w | x 即为 00000111，就是7 3. &lt;&lt; 向左移位移&lt;&lt;简单例子(向左移一位，右边自动补0)11 &lt;&lt; 1 = 22 00001011 &lt;&lt; 1 00010110 = 22 相当于二进制的每个数都变成当前值的两倍，结果就是变成当前值的两倍。 n * 2 == (n &lt;&lt; 1) 4. &gt;&gt; 向右位移&gt;&gt;简单例子(向右移一位，左边自动补1)11 &gt;&gt; 1 = 5 00001011 &gt;&gt; 1 00000101 = 5 注意到最后一位的1被干掉了。 比较实用的例子是: int n = n / 2 等价于 int n = n &gt;&gt; 1 等价于 int n &gt;&gt;= 1 5. ^ 异或两个相同的数会变成0，反之是1 11^3 = 8 00001011 ^ 00000011 = 00001000 = 8 Given an array of integers, every element appearstwice except for one. Fnd that single one. 在一个数组中，所有数字都出现了两次，只有一个没有 异或是嫉妒成双成对的。 比如 int t = {1,2,3,3,2,1,5} 要找到5。 用异或就完美了，所有相同的都会消失，留下来的就是5了。 intsingleNumber(int A[], int n) { for(int i = 1; i &lt; n; ++i) { A[0] ^= A[i]; } return A[0]; } 还有就是用不tmp值来交换两个数 //不用temp交换两个整数 voidswap(int&amp; x , int&amp; y) { x ^= y; y ^= x; x ^= y; } 6.~这个在加法中用到 x-y = x + ~y + 1 所以~y = - y -1 比如 ~11 = -11 -1 = -12 7.%(快速取模)求 100 % 8的 优化解法。 我们知道8刚好是2的3次方， 所以 100 % 8 == 100 - math.floor(100 / 8) * 8 == 100 - ((100 &gt;&gt; 3) &lt;&lt; 3)。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://roy1994.top/categories/笔记/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://roy1994.top/tags/基础知识/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://roy1994.top/categories/笔记/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2021-07-22T07:04:06.000Z","updated":"2021-12-05T07:04:37.156Z","comments":true,"path":"2021/07/22/最小生成树/","link":"","permalink":"https://roy1994.top/2021/07/22/最小生成树/","excerpt":"","text":"最小生成树有两种算法 Prim &amp; Kruskal 1. Prim#include&lt;bits/stdc++.h&gt; using namespace std; #define inf 0x7fffffff #define maxn 5005 int cost[maxn][maxn],minn,n,m,v2[maxn],tot=1,now,ans; bool v1[maxn]; inline void getcost() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { cost[i][j]=inf; } } for(int i=1,u,v,w; i&lt;=m; i++) { scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); if(cost[u][v]&gt;w) { cost[u][v]=cost[v][u]=w; } }//初始化cost数组 for(int i=1; i&lt;=n; i++) { v2[i]=cost[1][i]; } v1[1]=1;//找出与1节点相连的边并进行标记 } inline int prim() { while(tot&lt;n) { //最小生成树的概念 minn=inf; tot++; for(int i=1; i&lt;=n; i++) { if(!v1[i]&amp;&amp;v2[i]&lt;minn) { minn=v2[i]; now=i; } }//找出最小边 ans+=minn;//更新答案 for(int i=1; i&lt;=n; i++) { if(v2[i]&gt;cost[now][i]&amp;&amp;!v1[i]) { v2[i]=cost[now][i]; } } v1[now]=1;//在找出与now节点相连的边并进行标记 } return ans; } int main() { getcost(); printf(&quot;%d&quot;,prim()); return 0;//主函数不解释 } 2. Kruskal#include&lt;bits/stdc++.h&gt; #define max(a,b) return a&gt;b?a:b using namespace std; struct Edge{int pointA,pointB,w;}edge[200005]; int father[5005],n,m,ans,eu,ev,cnt; inline bool cmp(Edge a,Edge b){return a.w&lt;b.w;}//快排的依据 inline int findfather(int x){ while(x!=father[x]) x=father[x]=father[father[x]]; return x; }//并查集模板，用while循环比递归版快 inline void kruskal(){ sort(edge+1,edge+m+1,cmp);//将边的权值排序 for(int i=1;i&lt;=m;i++){ eu=findfather(edge[i].pointA), ev=findfather(edge[i].pointB); if(eu==ev) continue;//若出现环，则continue ans+=edge[i].w;//更新答案 father[ev]=eu; cnt++; if(cnt==n-1) break;//循环结束条件 } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) father[i]=i;//初始化并查集 for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;edge[i].pointA,&amp;edge[i].pointB,&amp;edge[i].w); kruskal(); printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://roy1994.top/tags/algorithm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"Segment-Tree-ZKW-PART-TWO","slug":"Segment-Tree-ZKW-PART-TWO","date":"2021-07-22T07:02:24.000Z","updated":"2021-12-05T07:03:47.961Z","comments":true,"path":"2021/07/22/Segment-Tree-ZKW-PART-TWO/","link":"","permalink":"https://roy1994.top/2021/07/22/Segment-Tree-ZKW-PART-TWO/","excerpt":"","text":"本来想看看网上的讲解的，结果发现都讲得不清楚，还是自己写一个吧 普通线段树与ZKW线段树 普通线段树通过递归建树，因而其常数相对较大 普通线段树代码长，相对较复杂 ZKW线段树通过循环建树，相对常数小 ZKW线段树代码短，易理解 ZKW线段树 · 无差分弱化版线段树是一种堆式储存结构，观察其节点编号 将其转化成二进制 规律是很显然的 一个节点的父节点是这个数左移1，这个位运算就是低位舍弃，所有数字左移一位 一个节点的子节点是这个数右移1，是左节点，右移1 +1是右节点 同一层的节点是依次递增的，第$n$层有$2^{n-1}$个节点 最后一层有多少节点，值域就是多少(这个很重要) 有了这些规律就可以开始着手建树了 若树的层数为 $m$ ，则最后一层的节点数 $cnt$ 满足 $cnt = 2^{m-1}$ 若数的个数为 $x$ ，则数的个数x满足 $\\frac {cnt}{2} &lt; x &lt;= cnt$（大于$x$小于$cnt$的部分无视） 底层节点序号从 $cnt$ 开始，一直到 $cnt+n-1$ 结束，第 $p$ 个数编号为 $cnt+p-1$ 所以我们需要先算出这个 $cnt$ 的最小值 for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1);//这里没有等号，以保证cnt最小 建树int n,a[10005]; struct node { int num; }Tree[10005]; inline void build(int n) { for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); } 这仅仅是对叶子节点进行操作，之后，我们要依次更新父节点由于是自下往上更新，所以，我们应当从 $cnt-1$ 开始，一直到 $1$ for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; 最后的建树代码 inline void build(int n) { for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; } 单点操作直接修改 inline void change(int x,int k) { Tree[cnt+x-1].num+=k; while(x) Tree[x&gt;&gt;=1].num=Tree[x&lt;&lt;1].num+Tree[x&lt;&lt;1|1].num;//更新 } 单点查询直接修改 inline int askpot(int pos) { return Tree[cnt+pos-1]; } ZKW线段树 · 差分版建树我们发现，上面的方法对于区间操作时间复杂度会很高，因此，我们可以使用差分思想来进行优化 此时，线段树节点存的值是他和父节点的差值我们再来写一下差分版的build void build(int n) { for (cnt = 1; cnt &lt; x; cnt &lt;&lt;= 1); for (int i = cnt; i &lt; cnt + n; i++) Tree[i].num = read(); for (int i = cnt - 1; i &gt;= 1; i--) { Tree[i].num = min(Tree[i &lt;&lt; 1].num, Tree[i &lt;&lt; 1 | 1]); Tree[i &lt;&lt; 1].num -= Tree[i]; Tree[i &lt;&lt; 1 | 1].num -= Tree[i]; } } 单点查询由于差分的性质只需依次向上累加就可以求出改点的值 inline int askpot(int pos) { int sum=0,x=cnt+pos-1; while(x) sum+=Tree[x].num,x&gt;&gt;=1; return sum; } 区间查询 inline int askRange(int l,int r)","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://roy1994.top/tags/algorithm/"},{"name":"线段树","slug":"线段树","permalink":"https://roy1994.top/tags/线段树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"Segment-Tree-PART-ONE","slug":"Segment-Tree-PART-ONE","date":"2021-07-22T06:58:23.000Z","updated":"2021-12-05T07:03:39.258Z","comments":true,"path":"2021/07/22/Segment-Tree-PART-ONE/","link":"","permalink":"https://roy1994.top/2021/07/22/Segment-Tree-PART-ONE/","excerpt":"","text":"概念 线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为$O(logn)$。 操作下面我们从一个经典的例子来了解线段树 从数组arr[0...n-1]中查找某个数组某个区间内的最小值， 其中数组大小固定，但是数组中的元素的值可以随时更新。 我们可以用线段树来解决这个问题：预处理耗时$O(n)$，查询、更新操作$O(logn)$，需要额外的空间$O(n)$。根据这个问题我们构造如下的二叉树 叶子节点是原始组数arr中的元素 非叶子节点代表它的所有子孙叶子节点所在区间的最小值例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）： 由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含$n$个叶子节点的完全二叉树，它一定有$n-1$个非叶节点，总共$2n-1$个节点，因此存储线段是需要的空间复杂度是$O(n)$ 创建线段树子节点根据线段树的性质（完全二叉树），只需知道父节点，就可以计算出子节点的序号 inline LL getLeftNum(LL p) { return p&lt;&lt;1; } inline LL getRightNum(LL p) { return p&lt;&lt;1|1; } 树的存放和节点信息首先，我们需要判断我们需要维护的对象，可以是一个值，也可以是颜色，状态等 struct { int val;//可以添加col,status，lztag }Tree[N]; 建树操作我们使用递归操作来建树 当左端点和右段点相同时，意味着此时的$p$节点是叶子节点 二分当前区间，递归建树 注意，这里有两个尚未出现的东西，$pushup$函数和$lztag$标记 $pushup$函数用于从子节点向上依次更新父节点的值而$lztag$是用于区间修改的懒标记 void buildTree(LL p,LL l,LL r) { lztag[p]=0; if(l==r) {Tree[p]=a[l];return ;} LL mid=(l+r)&gt;&gt;1; buildTree(getLeftNum(p),l,mid); buildTree(getRightNum(p),mid+1,r); pushup(p); } pushup 操作$pushup$起到更新的作用，对于不同的需求，有不同的$pushup$操作 对于求和，可以这么写 inline void pushup(LL p) { Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]); } 而对于求 最大值/最小值 ，则可以这么写 inline void put_up(LL p) { Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]); //Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]); } 更新操作更新操作可以分为两种 单点操作 区间操作 单点操作（updataPot）明确变量名： （l ~ r） —— 可支配区间 （nedChangeL ~ nedChangeR） —— 需操作区间 mid —— 可支配区间中点 注 : 当$mid$不小于$nedChangeL$时 代表去 $l$ ~ $mid$ 更新是有意义的，所以，我们选择更新该区间 $mid$和$nedChangeR$同理 void updataPot(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num) { if(l==r) {Tree[p]=num;return ;} LL mid=(l+r)&gt;&gt;1; if(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num); if(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+1,r,getRightNum(p),num); put_up(p); } 区间操作（updataInterval）#区间操作需要引入一个概念 $lazytag$ :$lazytag$标注的是线段树中每个树的变化量，即 $\\Delta$ $lazytag$ 操作时正如其名，只对目前状态打上标记，等到更新时，才向下传递因此，引入另一个函数$pushdown$，用于更新其子节点的$lazytag$和本节点的数值 接下来给出$pushdown$的代码 inline void updataSum(LL p,LL l,LL r,LL num) { lztag[p]=lztag[p]+num; Tree[p]+=num*(r-l+1); } inline void put_down(LL p,LL l,LL r) { LL mid=(l+r)&gt;&gt;1; updataSum(getLeftNum(p),l,mid,lztag[p]); updataSum(getRightNum(p),mid+1,r,lztag[p]); lztag[p]=0; } 有了$pushdown$算法，我们可以完成$updata$操作 void updataInterval(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num) { if(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) {updataSum(p,l,r,num);return ;} put_down(p,l,r); LL mid=(l+r)&gt;&gt;1; if(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num); if(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+1,r,getRightNum(p),num); put_up(p); } 区间求值（query）区间求值时，我们进行了询问，而因为$lazytag$的原因，在求值之前，需先进行$pushdown$操作 LL getSum(LL qx,LL qy,LL l,LL r,LL p) { LL sum=0; if(qx&lt;=l&amp;&amp;r&lt;=qy)return Tree[p]; LL mid=(l+r)&gt;&gt;1; put_down(p,l,r); if(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p)); if(qy&gt;mid) sum+=getSum(qx,qy,mid+1,r,getRightNum(p)); return sum; } END","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://roy1994.top/tags/algorithm/"},{"name":"线段树","slug":"线段树","permalink":"https://roy1994.top/tags/线段树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"莫队","slug":"莫队","date":"2021-07-22T06:15:28.000Z","updated":"2021-12-05T07:04:08.492Z","comments":true,"path":"2021/07/22/莫队/","link":"","permalink":"https://roy1994.top/2021/07/22/莫队/","excerpt":"","text":"我们使用一道例题来帮助我们理解莫队算法 洛谷P1972 例题题目描述:HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你来解决这个问题。 输入输出格式:输入格式：第一行：一个整数N，表示项链的长度。 第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。 第三行：一个整数M，表示HH 询问的个数。 接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。 输出格式：M 行，每行一个整数，依次表示询问对应的答案。 输入输出样例输入样例#1:6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例#1：2 2 4 引入想象一下，如果用暴力算法进行求解的话，我们会选择开一个$cnt$数组，遍历区间，累加求解， 显然，这样的时间复杂度太高，肯定会爆掉，所以我们需要莫队算法 首先，我们定义两个指针$curl$，$curr$，每次询问我们通过移动这两个指针来框定区间， 假设一开始 $curl$ 指向 $4$ ，$curr$ 指向 $6$， 下一个询问要求区间 $3$ ~ $5$，那么我们 $curl–$ ，顺带插入 $3$ ，$curr–$，顺带删去 $6$， 注意当前的先后顺序$curl–$ 要求先减后加入，而 $curr–$ 要求先删去再减 同理，$curl++$ 要求先删去再加，而 $curr++$ 要求先加再加入 我们可以写出这一部分 int lsans;//表示该区间的答案 inline void add(int pos){lsans+=(++cnt[a[pos]]==1);}//加入 inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}//删去 while(curr&lt;rr) add(++curr);//变化范围 while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); 莫队的优化我们可以很容易的发现，如果面对特别设计的数据，上面的时间复杂度仍然很高 举个栗子，有6个询问如下： (1, 100) (2, 2) (3, 99) (4, 4) (5, 102) (6, 7) 我们如果直接按左端点上升排序， 用上述方法处理时，左端点会移动$6$次，右端点会移动移动$98+97+95+98+95=483$次。 我们可以先按左端点上升排序，如果左端点所在的块相同，再在块内按右端点上升排序，得到结果就像这样 (2, 2) (4, 4) (6, 7) (5, 102) (3, 99) (1, 100) 左端点移动次数为$2+2+1+2+2=9$次，比原来稍多。右端点移动次数为$2+3+95+3+1=104$，右端点的移动次数大大降低了。 $Code$：struct ques { int l , r , id ; }que[100005]; bool cmp(const ques &amp;a,const ques &amp;b) { return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l; } 最终的代码#pragma GCC optimize(3) #include &lt;bits/stdc++.h&gt; #define sync_with_stdio(false) using namespace std; inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)w=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) s=s*10+ch-&#39;0&#39;,ch=getchar(); return s*w; } struct ques { int l , r , id ; }que[100005]; int n,m, blo,lsans; bool cmp(const ques &amp;a,const ques &amp;b) {return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;} int a[100005],cnt[1000005],ans[100005]; inline void add(int pos){lsans+=(++cnt[a[pos]]==1);} inline void del(int pos){lsans-=(--cnt[a[pos]]==0);} int main() { n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); m=read();blo=sqrt(m); for(int i=1;i&lt;=m;i++) { que[i].l=read(),que[i].r=read(); que[i].id=i; } sort(que+1,que+m+1,cmp); int curl=0,curr=0; for(int i=1;i&lt;=m;i++) { int ll=que[i].l,rr=que[i].r,idd=que[i].id; while(curr&lt;rr) add(++curr); while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); ans[idd]=lsans; } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;, ans[i]); }","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://roy1994.top/tags/algorithm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"bitset讲解","slug":"bitset讲解","date":"2021-07-21T16:34:34.000Z","updated":"2021-12-05T07:03:10.599Z","comments":true,"path":"2021/07/22/bitset讲解/","link":"","permalink":"https://roy1994.top/2021/07/22/bitset讲解/","excerpt":"","text":"为了写一道毒瘤题，决定学一下 bitset 头文件 #include&lt;bitset&gt; 同时需要命名空间 std 定义bitset &lt;N&gt; bs // 默认的构造函数将其初始为全0 有一个值得注意的地方，bitset 的 $bs[0]$ 是最后一位，而 $bs[N-1]$ 是第一位 std::bitset&lt;8&gt; bs; //bs[0] = 1; // 0000 0001 //bs[7] = 1; // 1000 0000 构造函数std::bitset&lt;8&gt; bs(7); // 0000 0111 std::bitset&lt;8&gt; bs(0x07); // 0000 0111 bitset&lt;numeric_limits&lt;unsigned short&gt;::digits&gt; bs1(267); // 16位 bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt; bs2(267); // 32位 std::bitset&lt;8&gt; bs(&quot;00000111&quot;); // 7 操作 成员函数 功能 bs.any() 是否存在值为 1 的二进制位 bs.none() 是否不存在值为 1 的二进制位 或者说是否全部位为 0 bs.size() 位长，也即是非模板参数值 bs.count() 值为 1 的个数 bs.test(pos) 测试 pos 处的二进制位是否为 1 返回和0做或运算的值 bs.set() 全部位置重置为 1 bs.set(pos) pos 位的二进制位置与 1 做或运算 bs.reset() 全部位置重置为 0 bs.reset(pos) pos 位的二进制位置与 0 做或运算 bs.flip() 全部位逐位取反 bs.flip(pos) pos处的二进制位取反 bs.to_ulong() 将二进制转换为unsigned long输出 bs.to_string() 将二进制转换为字符串输出 ~bs 按位取反 效果等效为 bs.flip() os &lt;&lt; b 将二进制位输出到os流 小值在右，大值在左 运算bitset 的运算就像一个普通的整数一样，可以进行 与 ( &amp; ) 、或 ( | ) 、 异或 ( ^ )、 左移 ( &lt;&lt; ) 、 右移 ( &gt;&gt; ) 等操作。 bitset&lt;4&gt; foo (std::string(&quot;1001&quot;)); bitset&lt;4&gt; bar (std::string(&quot;0011&quot;)); cout &lt;&lt; (foo^=bar) &lt;&lt; &#39;\\n&#39;; // 1010 (XOR,assign) cout &lt;&lt; (foo&amp;=bar) &lt;&lt; &#39;\\n&#39;; // 0010 (AND,assign) cout &lt;&lt; (foo|=bar) &lt;&lt; &#39;\\n&#39;; // 0011 (OR,assign) cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; &#39;\\n&#39;; // 1100 (SHL,assign) cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; &#39;\\n&#39;; // 0110 (SHR,assign) cout &lt;&lt; (~bar) &lt;&lt; &#39;\\n&#39;; // 1100 (NOT) cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; &#39;\\n&#39;; // 0110 (SHL) cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; &#39;\\n&#39;; // 0001 (SHR) cout &lt;&lt; (foo==bar) &lt;&lt; &#39;\\n&#39;; // false (0110==0011) cout &lt;&lt; (foo!=bar) &lt;&lt; &#39;\\n&#39;; // true (0110!=0011) cout &lt;&lt; (foo&amp;bar) &lt;&lt; &#39;\\n&#39;; // 0010 cout &lt;&lt; (foo|bar) &lt;&lt; &#39;\\n&#39;; // 0111 cout &lt;&lt; (foo^bar) &lt;&lt; &#39;\\n&#39;; // 0101 参考资料 C++ Reference CSDN by Inside_Zhang [胡小兔的OI博客](","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://roy1994.top/tags/STL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"Balance Tree(FHQ Treap)","slug":"Balance-Tree-FHQ-Treap","date":"2018-08-13T05:00:42.000Z","updated":"2021-12-05T07:03:01.124Z","comments":true,"path":"2018/08/13/Balance-Tree-FHQ-Treap/","link":"","permalink":"https://roy1994.top/2018/08/13/Balance-Tree-FHQ-Treap/","excerpt":"","text":"听说这个平衡树很好写，所以我尝试去学一下这个毒瘤的数据结构 FHQ Treap简介FHQ Treap只有两种主要的操作 分离（split） 把一棵树分成两个树 合并（merge） 把两棵树合成一棵树 通过 分离 和 合并 的操作，FHQ Treap可以完成普通平衡树的很多操作 插入 删除 查询排名为 $i$ 的数 查询 $wei$ 的排名 求 $wei$ 的前驱 求 $wei$ 的后继 反转区间 树的节点FHQ Treap 的节点维护的 普通Treap 维护的大致相同，我们通过一个结构体来保存信息相关含义如下： size —&gt; 子树（包括自身）的大小 val —&gt; 该节点的值 rnd —&gt; Treap中用于堆的随机值 l r —&gt; 左节点和右节点 下面给出代码： struct FHQ { int size,val,rnd; }tr[N]; 操作 1 : 插入按照普通treap的写法，我们需要新建一个节点，需要调用newnode函数 int tot=0; int newnode(int v) { tr[++tot].size=1;tr[tot].val=v,tr[tot].rnd=rand(); return tot;//返回新节点的编号 } 我们可以把原来的数按新节点的值分成两份，再依次合并，就完成了插入的过程 void ins(int wei) { int x,y; spilt(root,wei,x,y); //root表示目前总树的根节点 //把总树分成以x,y为根节点的两棵树 root=merge(merge(x,newnode(wei)),y); //合并所有子树并重置根节点 } 操作 2 ： 删除删除权值为 $wei$ 的点，先把整颗树以 $wei$ 为权值 $split$ 成两棵树 $x$，$y$，再把 $x$ 树按照 $wei-1$ 分成 $p$，$q$。 这时候值为wei的点一定为 $q$ 的根，那么我们把 $q$ 的两个子儿子 $merge$ 起来（这一步就是去除掉 $wei$ 的影响），再把他们重新 $merge$ 起来得到一个新的树，这颗树就去除掉了 $wei$ 的影响。 void del(int wei) { int x,int y,int p,int q; spilt(root,wei,x,y); split(x,wei-1,p,q); q=merge(tr[q].l,tr[q].r); root=merge(merge(p,q),y); } 操作 3 ： 查询排名为 i 的数和普通Treap是一样的， 但注意，这个函数返回的是 排名为 i 的数 的节点编号k（值为tr[k].val） 。 int getNum(int now,int rk) { while(1) { if(rk&lt;=tr[tr[now].l].size) now=tr[now].l; else { if(rk==tr[tr[now].l].size+1) return now; else { rk-=tr[re[now].l].size+1; now=tr[now].r; } } } } 操作 4 ： 查询 wei 的排名把总树按 $wei$ 进行 $spilt$ ，得到左部分树的大小即为rank值。 int getRank(int wei) { int x,y; spilt(root,wei,x,y); return tr[x].size; } 操作 5 ： 求 wei 的前驱把总树按 $wei-1$ 分成两份，所以小于 $wei$ 的节点都在左部分树中，只需要求出左部分树的size所对应的节点的值，就是所求的 $wei$ 的前驱。 int pre(int wei) { int x,y; spilt(root,wei-1,x,y); return tr[getNum(x,tr[x].size)].val; root=merge(x,y);//回复原状 } 操作 6 ： 求 wei 的后继找后继是相同的，把总树按 $wei$ 为权值调用 $split$，此时右部分树排名第一的数就是后继 int suc(int wei) { int x,y; spilt(root,wei+1,x,y); return tr[getNum(y,1)].val; root=merge(x,y);//回复原状 } 操作 7 ： 反转区间先咕着，有空补 核心 1： merge 操作$merge$ 操作即按照 FHQ Treap 的附加权值玄学维持平衡并进行合并 int merge(int x,int y)//x 恒&lt; y ,所以需要保证顺序 { if(!x||!y) return x+y; update(x),update(y); if(tr[x].rnd&lt;tr[y].rnd) { tr[x].r=merge(tr[x].r,y); update(x); return x; } else { tr[y].l=merge(x,tr[y].l); update(y); return y; } } 核心 2： spilt 操作$split$ 是把一颗Treap分开两个树的操作。 有两种分法，一种是按权值分，一种是按$size$（子树大小）分，具体用哪个要看情况。 按权值分 注意这时候权值小于等于 k的节点都在左树中，大于 k的都在右树中 ： void spilt(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(val&lt;=tr[tr[now].l].val) y=now,spilt(tr[now].l,val,x,tr[now].l); else x=now,spilt(tr[now].r,val,tr[now].r,y); update(now); } } 按 $size$ 分 ： void spilt(int now,int rnk,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(rnk&lt;=tr[tr[now].l].size) y=now,spilt(tr[now].l,rnk,x,tr[now].l); else x=now,spilt(tr[now].r,rnk-tr[tr[now].l].size-1,tr[now].r,y); update(now); } } END","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://roy1994.top/tags/algorithm/"},{"name":"平衡树","slug":"平衡树","permalink":"https://roy1994.top/tags/平衡树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]},{"title":"Git","slug":"git","date":"2018-08-13T05:00:42.000Z","updated":"2021-12-05T07:03:23.315Z","comments":true,"path":"2018/08/13/git/","link":"","permalink":"https://roy1994.top/2018/08/13/git/","excerpt":"","text":"使用基本设置ssh 配置 ssh-keygen -t rsa -C &quot;YourEmail@email.com&quot; \\r\\r\\r ... seek for &quot;.ssh&quot; in the user file copy &quot;id_rsa.pub&quot; 提交代码时的用户信息 git config --global user.name &quot;YourUsername&quot; git config --global user.email &quot;YourEmail@email.com&quot; 初始仓库初始化 git init 指定目录 dir git &lt;dir&gt; 常用操作跟踪文件/加入暂存区 git add * git add README git add *.c 加入本地仓库 git commit -m &quot;First&quot; //windows git commit -m &#39;First&#39; //linux 克隆仓库 git clone &lt;repo&gt; 基本操作查看仓库当前状态git status 回退版本 git reset HEAD^ // 回退所有内容到上一个版本 git reset HEAD^ hello.php // 回退 hello.php 文件的版本到上一个版本 git reset 052e // 回退到指定版本 git reset --soft HEAD~3 // 回退上上上一个版本 HEAD~0 表示当前版本 HEAD~1 上一个版本 HEAD^2 上上一个版本 HEAD^3 上上上一个版本 比较文件的不同 git diff 远程操作添加一个新的远程仓库 git remote add [shortname] [url] git remote add origin https://github.com/MoveCloudROY/cdn.git 显示所有远程仓库 git remote -v 从远程获取代码库 git fetch [alias] //获取远端的更新 git merge [alias]/[branch] //将服务器上的任何更新合并到你的当前分支 alias - 本地仓库 branch - 远程仓库 分支管理创建分支 git branch (branchname) 切换分支 git checkout (branchname) ​ - 创造并切换 git checkout -b change_site 列出分支 git branch 删除分支 git branch -d (branchname) 分支合并 git merge (branchname) //合并 branch 到主分支","categories":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"https://roy1994.top/tags/git/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://roy1994.top/categories/技术/"}]}]}