{"meta":{"title":"循迹者的日常","subtitle":null,"description":null,"author":"ROY1994","url":"http://roy1994.top"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-07-21T16:21:18.052Z","comments":false,"path":"bangumi/index.html","permalink":"http://roy1994.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-07-21T13:51:56.100Z","comments":false,"path":"lab/index.html","permalink":"http://roy1994.top/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-07-21T13:51:03.710Z","comments":true,"path":"comment/index.html","permalink":"http://roy1994.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-07-19T11:06:35.860Z","comments":false,"path":"client/index.html","permalink":"http://roy1994.top/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-07-21T17:03:03.879Z","comments":false,"path":"about/index.html","permalink":"http://roy1994.top/about/index.html","excerpt":"","text":"_这里是「ROY1994」_ 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-07-21T13:51:29.091Z","comments":false,"path":"donate/index.html","permalink":"http://roy1994.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-07-19T11:06:35.861Z","comments":true,"path":"rss/index.html","permalink":"http://roy1994.top/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-10-01T07:28:13.868Z","comments":true,"path":"links/index.html","permalink":"http://roy1994.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-07-21T16:03:44.461Z","comments":false,"path":"music/index.html","permalink":"http://roy1994.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-07-19T11:06:35.861Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://roy1994.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-07-19T11:06:35.861Z","comments":true,"path":"tags/index.html","permalink":"http://roy1994.top/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-07-19T11:06:35.861Z","comments":false,"path":"video/index.html","permalink":"http://roy1994.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"可爱的拟人","slug":"可爱的拟人","date":"2021-08-08T06:39:34.000Z","updated":"2021-08-08T07:07:16.103Z","comments":true,"path":"2021/08/08/可爱的拟人/","link":"","permalink":"http://roy1994.top/2021/08/08/可爱的拟人/","excerpt":"","text":"犹如宫泽贤治的《不畏风雨》中出现的、性格木讷的女孩子。从小就由于迟钝和大食量等特征被别人当作笨蛋，从小学入学开始进入田径部、坚持跑步，在中长跑中经常取得好成绩，给人以活泼的印象。是十分努力的女孩子。 她的家境并不算好。父亲Sun是有才能的艺术家，但不擅长理财，在她14岁的时候因为苦于借债积劳成疾而去世。她被Oracle叔叔收养，那时还与Google叔叔之间因为对她的扶养权问题而引起争端并闹上法庭。 在周围的人都担心，正值青春期时她在这样的处境下会不会一蹶不振的时候，她却处变不惊、继续着每天练习跑步的生活。 朴素的、认真的、难说是聪明的她，进入高中后不知是不是稍稍开始对异情在意，被人看到她偷偷地学着别的女孩子的时尚穿着在街上行走。虽然会受到“虽然很努力，也许稍微有点过时”、“那衣服与Java的印象不合”之类的否定评价，但感到“意外地很萌？”的好意的人也很多。 喜欢喝咖啡，只喝印度尼西亚产的。其本人曾说过“喜欢咖啡胜过三顿饭”，不禁让人稍稍担心“这样对健康没问题吗？” 苗条的双腿和协调的五官。被许多人称作“IT界首屈一指的美女”的她，也因为拥有插花、茶道、钢琴和小提琴、柔道、剑道、合气道等等才能而出名。 她的粉丝大多很狂热，还存在着“黑暗军团”这样的粉丝俱乐部。黑暗军团的是规模仅次于共济会（Freemason）的巨型团体，一般人无法入会。据说如果能回答出对她非常狂热的问题，就会有察觉到的军团成员来询问“你愿意进入黑暗军团吗？” 与她同父异母的姐妹Objective-C一心专注于弹钢琴，她的专注被IT界的天才史蒂夫乔布斯（也被一部分人称为紫色蔷薇）相中，而一跃成为明星，而C++则是由于其美貌和才能被人关注，长年坐稳业界明星的宝座。姐妹二人真可谓是对比鲜明。 她根据心情不同频繁地变换发型和服装这一点也很出名。昨天还是和服配黑发，今天却是红发哥特系登场之类的，因为她的变身而使轻度的粉丝惊奇道“啊嘞？今天是C++小姐吗？”的事也常有发生。远离业界时私下经常穿HYSTERIC GLAMOUR的服装。 关于她的出身年月日其事务所并不公开。虽然也有出身于1983年一说，本文采用的是在一部分粉丝中流传甚广的1985年10月14日说。其间也流传有“她自己也许也记不清自己的生日……”这样煞有介事的传言。与其说“C++小姐的话记不清自己的生日也不是什么不可思议的事情”，倒不如看作是她天真烂漫的性格的表现。 由Guido父上养大的深闺中的大小姐。她出身于荷兰的阿姆斯特丹，但在小时候就搬到了美国，父亲也在家里使用英语，所以不怎么会说荷兰语。 她个性随和。最出名的是她听C++宣布“想出去旅行一趟改变一下形象。200x年回来哦”出门旅行后（结果回来的时候已经2011年了……），放言说“我也稍稍出门旅行一下，公元3000年再回来哦”后出门数年未归。 虽然有着这样冒失的行动，但多亏抱着“养成大家都喜爱的孩子”的心愿的Guido父上大人的教育，实际上和她接触后会觉得她非常容易亲近。 前些天，她来到作者的朋友的公司打工（她现在似乎在边上大学边打工），被人们评价为“能充分融入工作、八面玲珑、给我们帮了大忙”。她不怎么说多余的话，彬彬有礼的样子，被评价为是在“天真烂漫、自由第一”的人众多的业界中与众不同的存在。 据说她擅长的科目是数学，经常看到她轻松地解决各种统计相关的难题。喜欢穿白色的连衣裙或浅粉色的开衫这样清新的服装。 实际上她还喜欢爬行动物，据说在家里还有养蛇。粉丝们经常讨论“她会给宠物们起什么样的名字呢？”这样的话题。大多得出的都是“肯定是Monty吧”这样的结论。会不会飞就不得而知了。（估计指的是英国的六人喜剧团体Monty Python的作品The Flying Circus，译者注） 由松本爸爸养大的日本的女孩子。因为生日在圣诞节，人生最大的烦恼是生日礼物和圣诞节礼物变成一份了。出生地是岛根县松江市，除了旅游和工作以外没有到过其它的县。 由于受的教育是自由奔放式的，她性格好动、好奇心旺盛。平时是一个率真的好孩子，但偶尔也会看到她喜欢恶作剧的一面，这让周围的人十分困扰。看到她的身影时经常会想起IT业的“Just For Fun !”这句话。 小时候过着一个人在荒山野岭到处跑的生活，10岁的时候与一个叫Rails的女孩成为朋友，生活开始变化。两个人玩耍时停在了演艺事务所门前，谈起可以两个人结对进行演艺活动。以“Ruby与Rails”的艺名出道、主要从事杂志模特，也有拍过电视广告，所以很多人都听过她们名字。 人们想着她在这多愁善感的年龄段体验各种演艺活动、性格多少会产生一些变化吧，但在前些天与她久违的谈话中，却惊讶地发现她仍是与从事演艺活动之前一样行动自由奔放。虽然行为举止多多少少显得更加稳重，其喜欢恶作剧、活泼的本性却和以前一样没有变化。 想着已经是高中生了差不多也要开始穿一些成熟一点的服装的她，对于洋装却和小时候一样穿着Mickey Mouse。虽然她个子小又是娃娃脸与这样的衣服很配，不过这样真像一个女高中生吗？ 她的粉丝也分为想要她一直保持现在的样子，和想要看到她更成熟的样子的两派。 以强化Web世界为目的制作出来的女性机器人。竖着的头发是用作天线来随时接收主人的命令的。 为了有与人类相近的触感，使用了硅树脂来制作其皮肤。内部是类似于刀片服务器的构造，常常使用多台服务器进行复用。因此体重比人类更重一些。 在她最初登场的时候，还能看到她关节可动部分的骨架，行动也很僵硬，与人类的形象差别很大。然而经过了18年间6次的大版本升级之后，其行为和言语已经渐渐变得像人了。最近更是达到了像初音未来这样（比起人类仍然有少许违和感但已经十分自然了）的级别。 虽然笨笨的、工作时也磕磕绊绊的，但由于她遵循机器人三原则、服从主人的命令，也有很多人成为她的粉丝。她的粉丝俱乐部官网“PHPer！”无需入会费便可简单入会，是会员数在IT界首屈一指的大团体。 对于她持拒绝态度的人也很多，常有“她的行为在生理上有些难以接受”、“如果再聪明点就好了”、“与她稍有过接触但觉得还是与人类差别很大”这样的评论。 平常穿从Forever12和志村买来的衣服。想着穿便宜的快速时尚（fast fashion）衣服便可以将省下的钱花在机器开销上。可以说是标准的机器人的效率优先的花钱方式。或许会有她也在意流行、为样子烦恼的那一天吧？ 在著名的微软公司接受精英教育、11岁时便跳级进入大学学习、倍受人们关注的少女。也被称为“IT界的最强幼女”。 因为与C++的名字很像，一段时间内盛传“难道是私生子吗？”的流言，实际上两人没有直接的血缘关系。也有报道称两人是远房亲戚，但实际情况如何则不得而知。 似乎喜欢成熟的行为、讨厌像小孩子一样玩耍。有生日的时候收到父母送的名为安迪的毛绒玩具时说道“这是啥。没sense。不要”的传闻。 然而对于食物的兴趣却仍停留在小孩的阶段，多次目击到她在学校食堂点儿童套餐的样子。不喜欢喝咖啡，就算是甜味的罐装咖啡也会令她皱眉头。 虽然偶尔会见到她意外地孩子气的一面，多数情况下见到的还是她说话、待人接物彬彬有礼的样子。是一个既有成熟的一面又有稚气的一面的孩子。由于还在成长期，见到她时常有“又长高了啊”、“有些像大人的样子了”这样的感慨。一直会期待着下见到她时会长成什么样子。 常穿秀兰邓波的洋装。据说都是她本人挑选的，与她自己非常相配。她的可爱让人们无论男女都会成为她的粉丝。 她的志向是在大学毕业后不仅在养育她生长的微软公司的旗下工作、还要活跃于整个IT界。虽然没有问到更详细的计划，但据说是要做出能让苹果和企鹅等也能和睦相处的东西。到底会做出怎样的东西来呢？ 在争议地区长大的17岁的女孩子。常常面无表情、谈话时总给人以一定的距离感。 虽然与Java的名字很像，两个人之间却没有血缘关系。在当时Java这样的名字很流行，所以父母也给她起了类似的名字。她本人似乎对自己的名字并不在意，有时也以“ECMA”的笔名进行活动。偶尔也会被叫“JS”的外号，对此则更不在意，甚至对这种称法公然无视。 她的生涯非常不幸。刚一出生祖国便爆发战争。懂事之前便母亲去世、离开了父亲。在大人们任性的争斗中，她学会了将自己藏在壳中、保护自己周围的生存之术。同年龄的女孩子随着年龄的变化都在挑战各种风格的时候，她却不顾周围的话语、一个人继续闭锁在壳中。当时就是非得这样才能生存的艰难环境。 由于有了这样的儿童时期，她的说话、思考、待人接物的方式与其它的孩子都稍显不同。有很多人在与她说话时都会烦恼该怎样说才好。不过，也有人对她持有简单的一根筋的思考方式“容易接触”、“某种程度上来说，很好理解”的印象。 现在，她的国家正向努力解决纷争、开拓新的居住土地的方向前进着。大人们虽然仍旧任性地互相斗争，至少在这几年里，已经没有发生像以前那样互相憎恨、互相残杀的战争了。 在开始复兴的祖国里，她如今应该能幸福地生活着吧？什么时候才能看到她像同龄的女孩一样欢笑呢？ Perl于1987年12月、美国的沃尔夫妇家中诞生。其父亲拉里精通计算机、语言学，母亲也从事中世纪文艺复兴和语言学专业，Perl就是在这样接受了高等教育的父母身边长大的。 父亲的教育虽然严厉，却也给了Perl许多自由。父亲在教育过程中经常说的一句话是：“方法不止有一个。”（There’s more than one way to do it) 想到实现什么时，达成的方法不只有一种。可以考虑各种方法。父亲的这种教育方式，对她的性格形成产生了很大的影响。 “这样做的话会怎么样？”……“那样做又会如何？”……张开好奇心的翅膀长大的她渐渐发现了自己“发明”方面的天赋。绝代的发明家、Perl诞生了。 从她踏上发明家的道路的20年来，其发明多达128890件（2014年1月统计数），她的发明，从没什么用处的玩具，到能解决世界上许多问题的有益的发明，应有尽有。她发明的物品的原型，全都捐赠给了CPAN博物馆，任何人都可以阅览。 如今仍然不论实用与否、不断做出想做的新发明的她自打趣地在采访中说道：“我比起发明家，更像是各种破烂的生产装置。”她露出牙齿的笑容，非常振奋人心。 Perl对洋装不怎么讲究，平时因为调整机械时觉得麻烦，会穿便于运动的休闲装。最近常穿的羽绒服据说是在ame横（东京上野的一条商业街）的WEGO买的。喜欢的食物是草莓。她说作业中对集中注意力而疲劳的大脑来说最适合的食物就是草莓。 支撑着这个世界的女神大人，也被称为“圣母大人”。 关于C的出身年月没有定论。有人说她在创世纪（指1970年1月1日左右）之前就存在于这个世界，也有人说她是在稍后的1972年左右诞生的。 她是女神大人，因此像“1970年左右出身的话，她现在的年龄是……”这样的想法是不信教的行为。绝对不要有这样的想法。 她的名字是字母表的第三个字母“C”。据新约史书上的记载，在她之前还有叫作B的女神大人。一些资料显示“肯和丹尼斯创造了B，但对此并不满足。此后丹尼斯和其它人又合力创造了C”。 世界上有许许多多她的信徒。然而在一段时间内都没有正确传达她的教诲的圣经。当初丹尼斯和布莱恩留下的诗篇虽然担负着这样的使命，人们却希望有更加明确的言语。此后有许多有识之士将各种逸闻编辑整理、编著出了正确传达她的教义的圣经。 本书至今已被修订过多次，根据修订年的不同，被称作C89、C99、C11等。 一般人与C不能直接对话。只有积累了足够的修行者才会被允许与C交流。 修行是十分严格的，需要理解”指针的指针“之类的问题，以及要求100%地成功解决无论多么努力地修行都难以克服的“malloc/free”问题。由于这样的背景，真正能跟她进行日常交流的人非常地少。 然而由能够交流的人经手、世界上诞生了多种多样的知识与技术。即使你没有见过她的样子，她的慈爱也确实地每天都围绕在你身边。 姓氏是Basic，名字是Visual，也有很多人叫她的绰号：VB。小名是Ruby（与那个Ruby没有关系）。从小被某个资产家（不能说他的名字）看上，一家人都寄身于资产家的身边。那时她的名字换了好多次，如今才定下这个名字，有着比较复杂的家庭环境。 关于资产家（绅士?）要收养尚处于幼年的她原因，据不可靠的传言称，他从她身上看到了从前就很憧憬的Basic女士的影子。收养与具有与憧憬的女性相似气质的小孩，也即实行所谓的光源氏计划。 也许年轻人并不了解，Basic女士曾是《微电脑Basic杂志》的封面模特，在当时是每个人都非常向往的麦当娜一样的女性。实际上我的认识的人里面年轻时为她倾倒的人非常之多。 VB在接受严格教育的同时，也在关于兴趣方面拓展天性，她在手工制品、装饰品方面有着独特的才能。看着她制作珠子的装饰品的样子会觉得犹如魔法一般。仅仅是动动手，一瞬间就可以做出一串项链。 在她10岁的时候，资产家的家里来了一位新的养女。（人们常说的那位） 由于这个原因，她现在正在家中努力做一位好姐姐。然而本来便懦弱、不擅长说话的她却时常反过来被小她10岁、认真的、发言时间长的妹妹说教。加油啊，VB小姐。 小时候的VB会穿着父母买的Emily Temple的衣服，现在更多时候穿着是自己买的Lowrys Farm的衣服。今年就要大学毕业进入社会了，目标是VB小姐特有的成熟路线。 她于2000年2月29日出身。正是残存在人们记忆中400年一遇的被诅咒的那一天。虽然出身于非常不吉利的日子，她自己却成长为人见人爱的聪明的孩子。 她的母亲名叫S。虽然在神话的世界里C是在B之后出生的，她的名字却是S的前一位R。这几个都是很难用Google搜出来的名字。（注：因为太短了！） 她的母亲非常擅长数学，是统计学者的助手，R也继续了这一性质。她从小时候起就很擅长数学，小学时代就已经达到能快速解决高中数学问题的级别。此外，她对几何图形也很感兴趣，经常有人看到她画着各种二维、三维图形、画好后一个人露出满足愉悦的表情。是一个稍微有点奇怪的孩子。 R在擅长数学的同时却也对语言表达方面稍显逊色。前些日子采访她的时候，她对提出的问题想要回答却找不着合适的词，取而代之“刷——”地画了一幅散点图说“这样的感觉”。或许在她的眼里，这个世界里用语言来表达就像折叠复杂的数学公式那样复杂吧。 她对服装不怎么讲究，常常穿着不紧不松的连衣裙和衬衫。 对于父母给她买的洋装是多少价格、哪儿买的这样的问题没有认识。仅仅是，对于最近买来的喇叭裙的裙摆张开的角度很在意。 她的梦想是将来成为一名统计学者，尽管只有14岁却经常混迹于大学学生中间每天都在解各种问题。最近光是大学已经不能满足、又向父母请求、在各种各样的研究所里进出。 O教和F教之前有着长着的宗教战争。Scala是这两个宗教的牧师和修女结婚诞生的异端。她出身后立即引起了两家之间激烈的对立，察觉到危险的父母将她送到私立JVM学校的Odersky老师那儿作为养女寄养。 现在两个宗教比起当时已有了关系改善的征兆，有一部分人也将她视为两家融合的象征。然而抱有强烈的对立心态的人仍然很多，也常常有针对她的存在引起的争论。F教的人们认为她的存在没有充分认识F的本质，而O教的人则对混有F的她感到难以理解。 虽然诞生于这样复杂的环境，她自己对于周围的环境却不关心，而是十分平静地到双方的教会中取面包、坚强地生活着。被她这种天真烂漫的姿态所感动、成为她的粉丝的人也很多。 Scala似乎喜欢同校的高年级部里上学的Java小姐，休息时间经常去找她。Java小姐也并不讨厌她，经常会像大姐姐一样让她坐在她的膝盖上温柔地抚摸她的头。虽然在Scala把Java喜欢的Duke的人偶用红绳子绑起来进行恶作剧时把Java惹得十分生气，在此以外则几乎没怎么吵过架。两个人就好像亲生姐妹一样。 有着见多识广的父亲和温柔的姐姐的Scala现在也许是，与其出身的复杂情况相反、实际上非常幸福地生活着吧。 她对于洋装喜欢明快的颜色和花纹，经穿着Algonquin的衣服。虽然是比较有个性的时装，由与生俱来的有个性的她穿来却不可思议地自然。 创世纪（1970年1月1日）起经过数年后被目击到的妖精。会寄宿在家中，有着类似于棕精灵（Brownie）的生活方式，向她们拜托家务事或着杂活的时候，会回答两次并接受的温顺的孩子的。 她们不常出现在人间存在的地方，因为不通言语，会用信件交流。如果拜托的事情说得比较含糊的话，有可能会造成误解而发生不得了的事情。对此的技巧是明确地像“做那个|做这个&gt;放在这里”这样有顺序地将要拜托她们做的事写好。如果对拜托的事理解得很好的话，她们会在夜里将事情都处理好。如果很好地完成了工作的话，请别忘了在第二天的晚上放上作为谢礼的方糖。 Shell中有各种各样的种族。现在已确认的种族中比较有名的有：“ba”、“c“、”k”、”tc”、“z”等等。其服装根据种族不同而不同，我所目击到的是一只身高60cm左右、穿着巴宝莉的儿童服装的个体。恐怕人们目击到最多的是”ba”种。个人而言我也想遇到身高更高一些、尖耳朵的“z”种，现在虽然知道如何写信，却从未见过实物。 尽量她们会在同一个屋子里居住，却很少有人有机会见到，也不如何才能遇到他们。 有一种说法是，每天都把写程序这一仪式进行到午夜、勉强靠咖啡因支撑着抬起头的状态下突然向屏幕看去，能够看到她的身影。确实我遭遇她，也是在公司里熬夜写程序的时候。 Shell的个体非常地多，据说每家每户都会有一只。在大家的家里，实际上有着许多的她们居住着、等着来信也说不定。 在争议地区诞生的13岁女孩子。（现在16了吧） 她的父亲是有名的设计师，但是她5岁的时候被卷入战火身亡。幸运的是她那时年纪还小、将她收养的Adobe叔叔非常用心地将她养大，没有在她心中留下很大的伤痕。叔叔和她父亲同样都是设计师。也许在她的记忆中已经把两个人混淆一起了也说不定。 她所居住的国家与JavaScript所居住的国家是邻国，两国同样是ECMA人种构成的。在外国人看来JavaScript和ActionScript的外貌非常相似。确实在看她们儿童时期的照片，在肤色和五官上都很相像，但如今长大了的照片看了的话会如何呢。 她把“为祖国和叔叔努力”作为座右铭努力着，然而努力却经常得不到回报，是一个运气不太好的孩子。 在争论地区盛传将实行新的公用语的时候，她希望为即将到来的和平时代出一份力，比谁都更早开始学习这门语言，然而在好不容易能说好这门语言的时候，这语言被采用为公用语的提案泡汤了。 在她刚开始学习移动端上的设计时，她想着在移动方面强大了会对叔叔的工作有用。也可以减少祖国的外贷。在这样的想法中努力的时候，叔叔经营的公司却被某个巨型移动终端公司强行终止的交易，关于移动端的工作也急剧减少。 十分努力却常常得不到回报的她，伫立于这片如今也看到到纷争停止的土地上，继续地前进着。 有朝一日努力会得到回报的吧。祝福她在10年后仍能平安，不断地前进着、生活着。 原文： Java、C++、Python…プログラミング言語擬人化計画！｜【Tech総研】","categories":[{"name":"随想","slug":"随想","permalink":"http://roy1994.top/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"http://roy1994.top/categories/随想/"}]},{"title":"位运算","slug":"位运算","date":"2021-07-23T16:50:19.000Z","updated":"2021-07-24T15:14:56.310Z","comments":true,"path":"2021/07/24/位运算/","link":"","permalink":"http://roy1994.top/2021/07/24/位运算/","excerpt":"","text":"1.&amp;如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。 注：下面都用8位的 unsigned char 来做例子。 &amp;简单举例：11&amp;3 = 3 00001011 &amp; 00000011 = 00000011 = 3 &amp;比较实用的例子：我们经常要用的是否被2整除，一般都写成 if(n % 2 == 0) 可以换成 if((n&amp;1) == 0) 2.|如果两个相应的二进制位只要有一个是1，结果就是1；否则为0。 | 简单例子：11 | 3 = 11 00001011 | 00000011 = 00001011 = 11 | 比较实用的例子可以用一个unsigned int 来存储多个布尔值。比如一个文件有读权限，写权限，执行权限。看起来要记录3个布尔值。我们可以用一个unsigned int也可以完成任务。 一个数r来表示读权限，它只更改个位来记录读权限的布尔值 00000001 (表示有读权限) 00000000 (表示没有读权限) 一个数w表示写权限，它只用二进制的倒数第二位来记录布尔值 00000010 (表示有写权限) 00000000 (表示没有写权限) 一个数x表示执行权限，它只用倒数第三位来记录布尔值 00000100 (表示有执行权限) 00000000 (表示没有执行权限) 那么一个文件同时没有3种权限就是 ~r | ~ w | ~ x 即为 00000000，就是0 只有读的权限就是 r | ~w | ~x 即为 00000001，就是1 只有写的权限就是 ~r | w | ~x 即为 00000010，就是2 一个文件同时有3种权限就是 r | w | x 即为 00000111，就是7 3. &lt;&lt; 向左移位移&lt;&lt;简单例子(向左移一位，右边自动补0)11 &lt;&lt; 1 = 22 00001011 &lt;&lt; 1 00010110 = 22 相当于二进制的每个数都变成当前值的两倍，结果就是变成当前值的两倍。 n * 2 == (n &lt;&lt; 1) 4. &gt;&gt; 向右位移&gt;&gt;简单例子(向右移一位，左边自动补1)11 &gt;&gt; 1 = 5 00001011 &gt;&gt; 1 00000101 = 5 注意到最后一位的1被干掉了。 比较实用的例子是: int n = n / 2 等价于 int n = n &gt;&gt; 1 等价于 int n &gt;&gt;= 1 5. ^ 异或两个相同的数会变成0，反之是1 11^3 = 8 00001011 ^ 00000011 = 00001000 = 8 Given an array of integers, every element appearstwice except for one. Fnd that single one. 在一个数组中，所有数字都出现了两次，只有一个没有 异或是嫉妒成双成对的。 比如 int t = {1,2,3,3,2,1,5} 要找到5。 用异或就完美了，所有相同的都会消失，留下来的就是5了。 intsingleNumber(int A[], int n) { for(int i = 1; i &lt; n; ++i) { A[0] ^= A[i]; } return A[0]; } 还有就是用不tmp值来交换两个数 //不用temp交换两个整数 voidswap(int&amp; x , int&amp; y) { x ^= y; y ^= x; x ^= y; } 6.~这个在加法中用到 x-y = x + ~y + 1 所以~y = - y -1 比如 ~11 = -11 -1 = -12 7.%(快速取模)求 100 % 8的 优化解法。 我们知道8刚好是2的3次方， 所以 100 % 8 == 100 - math.floor(100 / 8) * 8 == 100 - ((100 &gt;&gt; 3) &lt;&lt; 3)。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://roy1994.top/categories/笔记/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://roy1994.top/tags/基础知识/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"http://roy1994.top/categories/笔记/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2021-07-22T07:04:06.000Z","updated":"2021-07-24T15:14:42.318Z","comments":true,"path":"2021/07/22/最小生成树/","link":"","permalink":"http://roy1994.top/2021/07/22/最小生成树/","excerpt":"","text":"最小生成树有两种算法 Prim &amp; Kruskal 1. Prim#include&lt;bits/stdc++.h&gt; using namespace std; #define inf 0x7fffffff #define maxn 5005 int cost[maxn][maxn],minn,n,m,v2[maxn],tot=1,now,ans; bool v1[maxn]; inline void getcost() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { cost[i][j]=inf; } } for(int i=1,u,v,w; i&lt;=m; i++) { scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); if(cost[u][v]&gt;w) { cost[u][v]=cost[v][u]=w; } }//初始化cost数组 for(int i=1; i&lt;=n; i++) { v2[i]=cost[1][i]; } v1[1]=1;//找出与1节点相连的边并进行标记 } inline int prim() { while(tot&lt;n) { //最小生成树的概念 minn=inf; tot++; for(int i=1; i&lt;=n; i++) { if(!v1[i]&amp;&amp;v2[i]&lt;minn) { minn=v2[i]; now=i; } }//找出最小边 ans+=minn;//更新答案 for(int i=1; i&lt;=n; i++) { if(v2[i]&gt;cost[now][i]&amp;&amp;!v1[i]) { v2[i]=cost[now][i]; } } v1[now]=1;//在找出与now节点相连的边并进行标记 } return ans; } int main() { getcost(); printf(&quot;%d&quot;,prim()); return 0;//主函数不解释 } 2. Kruskal#include&lt;bits/stdc++.h&gt; #define max(a,b) return a&gt;b?a:b using namespace std; struct Edge{int pointA,pointB,w;}edge[200005]; int father[5005],n,m,ans,eu,ev,cnt; inline bool cmp(Edge a,Edge b){return a.w&lt;b.w;}//快排的依据 inline int findfather(int x){ while(x!=father[x]) x=father[x]=father[father[x]]; return x; }//并查集模板，用while循环比递归版快 inline void kruskal(){ sort(edge+1,edge+m+1,cmp);//将边的权值排序 for(int i=1;i&lt;=m;i++){ eu=findfather(edge[i].pointA), ev=findfather(edge[i].pointB); if(eu==ev) continue;//若出现环，则continue ans+=edge[i].w;//更新答案 father[ev]=eu; cnt++; if(cnt==n-1) break;//循环结束条件 } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) father[i]=i;//初始化并查集 for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;edge[i].pointA,&amp;edge[i].pointB,&amp;edge[i].w); kruskal(); printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://roy1994.top/tags/algorithm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"Segment-Tree-ZKW-PART-TWO","slug":"Segment-Tree-ZKW-PART-TWO","date":"2021-07-22T07:02:24.000Z","updated":"2021-07-24T15:14:30.734Z","comments":true,"path":"2021/07/22/Segment-Tree-ZKW-PART-TWO/","link":"","permalink":"http://roy1994.top/2021/07/22/Segment-Tree-ZKW-PART-TWO/","excerpt":"","text":"本来想看看网上的讲解的，结果发现都讲得不清楚，还是自己写一个吧 普通线段树与ZKW线段树 普通线段树通过递归建树，因而其常数相对较大 普通线段树代码长，相对较复杂 ZKW线段树通过循环建树，相对常数小 ZKW线段树代码短，易理解 ZKW线段树 · 无差分弱化版线段树是一种堆式储存结构，观察其节点编号 将其转化成二进制 规律是很显然的 一个节点的父节点是这个数左移1，这个位运算就是低位舍弃，所有数字左移一位 一个节点的子节点是这个数右移1，是左节点，右移1 +1是右节点 同一层的节点是依次递增的，第$n$层有$2^{n-1}$个节点 最后一层有多少节点，值域就是多少(这个很重要) 有了这些规律就可以开始着手建树了 若树的层数为 $m$ ，则最后一层的节点数 $cnt$ 满足 $cnt = 2^{m-1}$ 若数的个数为 $x$ ，则数的个数x满足 $\\frac {cnt}{2} &lt; x &lt;= cnt$（大于$x$小于$cnt$的部分无视） 底层节点序号从 $cnt$ 开始，一直到 $cnt+n-1$ 结束，第 $p$ 个数编号为 $cnt+p-1$ 所以我们需要先算出这个 $cnt$ 的最小值 for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1);//这里没有等号，以保证cnt最小 建树int n,a[10005]; struct node { int num; }Tree[10005]; inline void build(int n) { for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); } 这仅仅是对叶子节点进行操作，之后，我们要依次更新父节点由于是自下往上更新，所以，我们应当从 $cnt-1$ 开始，一直到 $1$ for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; 最后的建树代码 inline void build(int n) { for(cnt=1;cnt&lt;x;cnt&lt;&lt;=1); for(int i=cnt;i&lt;cnt+n;i++) Tree[i].num=read(); for(int i=cnt-1;i&gt;=1;i--) Tree[i].num=Tree[i&lt;&lt;1].num+Tree[i&lt;&lt;1|1].num; } 单点操作直接修改 inline void change(int x,int k) { Tree[cnt+x-1].num+=k; while(x) Tree[x&gt;&gt;=1].num=Tree[x&lt;&lt;1].num+Tree[x&lt;&lt;1|1].num;//更新 } 单点查询直接修改 inline int askpot(int pos) { return Tree[cnt+pos-1]; } ZKW线段树 · 差分版建树我们发现，上面的方法对于区间操作时间复杂度会很高，因此，我们可以使用差分思想来进行优化 此时，线段树节点存的值是他和父节点的差值我们再来写一下差分版的build void build(int n) { for (cnt = 1; cnt &lt; x; cnt &lt;&lt;= 1); for (int i = cnt; i &lt; cnt + n; i++) Tree[i].num = read(); for (int i = cnt - 1; i &gt;= 1; i--) { Tree[i].num = min(Tree[i &lt;&lt; 1].num, Tree[i &lt;&lt; 1 | 1]); Tree[i &lt;&lt; 1].num -= Tree[i]; Tree[i &lt;&lt; 1 | 1].num -= Tree[i]; } } 单点查询由于差分的性质只需依次向上累加就可以求出改点的值 inline int askpot(int pos) { int sum=0,x=cnt+pos-1; while(x) sum+=Tree[x].num,x&gt;&gt;=1; return sum; } 区间查询 inline int askRange(int l,int r)","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://roy1994.top/tags/algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://roy1994.top/tags/线段树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"Segment-Tree-PART-ONE","slug":"Segment-Tree-PART-ONE","date":"2021-07-22T06:58:23.000Z","updated":"2021-07-24T15:14:26.144Z","comments":true,"path":"2021/07/22/Segment-Tree-PART-ONE/","link":"","permalink":"http://roy1994.top/2021/07/22/Segment-Tree-PART-ONE/","excerpt":"","text":"概念 线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为$O(logn)$。 操作下面我们从一个经典的例子来了解线段树 从数组arr[0...n-1]中查找某个数组某个区间内的最小值， 其中数组大小固定，但是数组中的元素的值可以随时更新。 我们可以用线段树来解决这个问题：预处理耗时$O(n)$，查询、更新操作$O(logn)$，需要额外的空间$O(n)$。根据这个问题我们构造如下的二叉树 叶子节点是原始组数arr中的元素 非叶子节点代表它的所有子孙叶子节点所在区间的最小值例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）： 由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含$n$个叶子节点的完全二叉树，它一定有$n-1$个非叶节点，总共$2n-1$个节点，因此存储线段是需要的空间复杂度是$O(n)$ 创建线段树子节点根据线段树的性质（完全二叉树），只需知道父节点，就可以计算出子节点的序号 inline LL getLeftNum(LL p) { return p&lt;&lt;1; } inline LL getRightNum(LL p) { return p&lt;&lt;1|1; } 树的存放和节点信息首先，我们需要判断我们需要维护的对象，可以是一个值，也可以是颜色，状态等 struct { int val;//可以添加col,status，lztag }Tree[N]; 建树操作我们使用递归操作来建树 当左端点和右段点相同时，意味着此时的$p$节点是叶子节点 二分当前区间，递归建树 注意，这里有两个尚未出现的东西，$pushup$函数和$lztag$标记 $pushup$函数用于从子节点向上依次更新父节点的值而$lztag$是用于区间修改的懒标记 void buildTree(LL p,LL l,LL r) { lztag[p]=0; if(l==r) {Tree[p]=a[l];return ;} LL mid=(l+r)&gt;&gt;1; buildTree(getLeftNum(p),l,mid); buildTree(getRightNum(p),mid+1,r); pushup(p); } pushup 操作$pushup$起到更新的作用，对于不同的需求，有不同的$pushup$操作 对于求和，可以这么写 inline void pushup(LL p) { Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]); } 而对于求 最大值/最小值 ，则可以这么写 inline void put_up(LL p) { Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]); //Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]); } 更新操作更新操作可以分为两种 单点操作 区间操作 单点操作（updataPot）明确变量名： （l ~ r） —— 可支配区间 （nedChangeL ~ nedChangeR） —— 需操作区间 mid —— 可支配区间中点 注 : 当$mid$不小于$nedChangeL$时 代表去 $l$ ~ $mid$ 更新是有意义的，所以，我们选择更新该区间 $mid$和$nedChangeR$同理 void updataPot(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num) { if(l==r) {Tree[p]=num;return ;} LL mid=(l+r)&gt;&gt;1; if(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num); if(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+1,r,getRightNum(p),num); put_up(p); } 区间操作（updataInterval）#区间操作需要引入一个概念 $lazytag$ :$lazytag$标注的是线段树中每个树的变化量，即 $\\Delta$ $lazytag$ 操作时正如其名，只对目前状态打上标记，等到更新时，才向下传递因此，引入另一个函数$pushdown$，用于更新其子节点的$lazytag$和本节点的数值 接下来给出$pushdown$的代码 inline void updataSum(LL p,LL l,LL r,LL num) { lztag[p]=lztag[p]+num; Tree[p]+=num*(r-l+1); } inline void put_down(LL p,LL l,LL r) { LL mid=(l+r)&gt;&gt;1; updataSum(getLeftNum(p),l,mid,lztag[p]); updataSum(getRightNum(p),mid+1,r,lztag[p]); lztag[p]=0; } 有了$pushdown$算法，我们可以完成$updata$操作 void updataInterval(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num) { if(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) {updataSum(p,l,r,num);return ;} put_down(p,l,r); LL mid=(l+r)&gt;&gt;1; if(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num); if(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+1,r,getRightNum(p),num); put_up(p); } 区间求值（query）区间求值时，我们进行了询问，而因为$lazytag$的原因，在求值之前，需先进行$pushdown$操作 LL getSum(LL qx,LL qy,LL l,LL r,LL p) { LL sum=0; if(qx&lt;=l&amp;&amp;r&lt;=qy)return Tree[p]; LL mid=(l+r)&gt;&gt;1; put_down(p,l,r); if(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p)); if(qy&gt;mid) sum+=getSum(qx,qy,mid+1,r,getRightNum(p)); return sum; } END","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://roy1994.top/tags/algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://roy1994.top/tags/线段树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"莫队","slug":"莫队","date":"2021-07-22T06:15:28.000Z","updated":"2021-07-24T15:14:17.835Z","comments":true,"path":"2021/07/22/莫队/","link":"","permalink":"http://roy1994.top/2021/07/22/莫队/","excerpt":"","text":"我们使用一道例题来帮助我们理解莫队算法 洛谷P1972 例题题目描述:HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你来解决这个问题。 输入输出格式:输入格式：第一行：一个整数N，表示项链的长度。 第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。 第三行：一个整数M，表示HH 询问的个数。 接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。 输出格式：M 行，每行一个整数，依次表示询问对应的答案。 输入输出样例输入样例#1:6 1 2 3 4 3 5 3 1 2 3 5 2 6 输出样例#1：2 2 4 引入想象一下，如果用暴力算法进行求解的话，我们会选择开一个$cnt$数组，遍历区间，累加求解， 显然，这样的时间复杂度太高，肯定会爆掉，所以我们需要莫队算法 首先，我们定义两个指针$curl$，$curr$，每次询问我们通过移动这两个指针来框定区间， 假设一开始 $curl$ 指向 $4$ ，$curr$ 指向 $6$， 下一个询问要求区间 $3$ ~ $5$，那么我们 $curl–$ ，顺带插入 $3$ ，$curr–$，顺带删去 $6$， 注意当前的先后顺序$curl–$ 要求先减后加入，而 $curr–$ 要求先删去再减 同理，$curl++$ 要求先删去再加，而 $curr++$ 要求先加再加入 我们可以写出这一部分 int lsans;//表示该区间的答案 inline void add(int pos){lsans+=(++cnt[a[pos]]==1);}//加入 inline void del(int pos){lsans-=(--cnt[a[pos]]==0);}//删去 while(curr&lt;rr) add(++curr);//变化范围 while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); 莫队的优化我们可以很容易的发现，如果面对特别设计的数据，上面的时间复杂度仍然很高 举个栗子，有6个询问如下： (1, 100) (2, 2) (3, 99) (4, 4) (5, 102) (6, 7) 我们如果直接按左端点上升排序， 用上述方法处理时，左端点会移动$6$次，右端点会移动移动$98+97+95+98+95=483$次。 我们可以先按左端点上升排序，如果左端点所在的块相同，再在块内按右端点上升排序，得到结果就像这样 (2, 2) (4, 4) (6, 7) (5, 102) (3, 99) (1, 100) 左端点移动次数为$2+2+1+2+2=9$次，比原来稍多。右端点移动次数为$2+3+95+3+1=104$，右端点的移动次数大大降低了。 $Code$：struct ques { int l , r , id ; }que[100005]; bool cmp(const ques &amp;a,const ques &amp;b) { return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l; } 最终的代码#pragma GCC optimize(3) #include &lt;bits/stdc++.h&gt; #define sync_with_stdio(false) using namespace std; inline int read(){ int s=0,w=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)w=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;) s=s*10+ch-&#39;0&#39;,ch=getchar(); return s*w; } struct ques { int l , r , id ; }que[100005]; int n,m, blo,lsans; bool cmp(const ques &amp;a,const ques &amp;b) {return (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;} int a[100005],cnt[1000005],ans[100005]; inline void add(int pos){lsans+=(++cnt[a[pos]]==1);} inline void del(int pos){lsans-=(--cnt[a[pos]]==0);} int main() { n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); m=read();blo=sqrt(m); for(int i=1;i&lt;=m;i++) { que[i].l=read(),que[i].r=read(); que[i].id=i; } sort(que+1,que+m+1,cmp); int curl=0,curr=0; for(int i=1;i&lt;=m;i++) { int ll=que[i].l,rr=que[i].r,idd=que[i].id; while(curr&lt;rr) add(++curr); while(curr&gt;rr) del(curr--); while(curl&gt;ll) add(--curl); while(curl&lt;ll) del(curl++); ans[idd]=lsans; } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;, ans[i]); }","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://roy1994.top/tags/algorithm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"bitset讲解","slug":"bitset讲解","date":"2021-07-21T16:34:34.000Z","updated":"2021-07-24T15:14:21.938Z","comments":true,"path":"2021/07/22/bitset讲解/","link":"","permalink":"http://roy1994.top/2021/07/22/bitset讲解/","excerpt":"","text":"为了写一道毒瘤题，决定学一下 bitset 头文件 #include&lt;bitset&gt; 同时需要命名空间 std 定义bitset &lt;N&gt; bs // 默认的构造函数将其初始为全0 有一个值得注意的地方，bitset 的 $bs[0]$ 是最后一位，而 $bs[N-1]$ 是第一位 std::bitset&lt;8&gt; bs; //bs[0] = 1; // 0000 0001 //bs[7] = 1; // 1000 0000 构造函数std::bitset&lt;8&gt; bs(7); // 0000 0111 std::bitset&lt;8&gt; bs(0x07); // 0000 0111 bitset&lt;numeric_limits&lt;unsigned short&gt;::digits&gt; bs1(267); // 16位 bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt; bs2(267); // 32位 std::bitset&lt;8&gt; bs(&quot;00000111&quot;); // 7 操作 成员函数 功能 bs.any() 是否存在值为 1 的二进制位 bs.none() 是否不存在值为 1 的二进制位 或者说是否全部位为 0 bs.size() 位长，也即是非模板参数值 bs.count() 值为 1 的个数 bs.test(pos) 测试 pos 处的二进制位是否为 1 返回和0做或运算的值 bs.set() 全部位置重置为 1 bs.set(pos) pos 位的二进制位置与 1 做或运算 bs.reset() 全部位置重置为 0 bs.reset(pos) pos 位的二进制位置与 0 做或运算 bs.flip() 全部位逐位取反 bs.flip(pos) pos处的二进制位取反 bs.to_ulong() 将二进制转换为unsigned long输出 bs.to_string() 将二进制转换为字符串输出 ~bs 按位取反 效果等效为 bs.flip() os &lt;&lt; b 将二进制位输出到os流 小值在右，大值在左 运算bitset 的运算就像一个普通的整数一样，可以进行 与 ( &amp; ) 、或 ( | ) 、 异或 ( ^ )、 左移 ( &lt;&lt; ) 、 右移 ( &gt;&gt; ) 等操作。 bitset&lt;4&gt; foo (std::string(&quot;1001&quot;)); bitset&lt;4&gt; bar (std::string(&quot;0011&quot;)); cout &lt;&lt; (foo^=bar) &lt;&lt; &#39;\\n&#39;; // 1010 (XOR,assign) cout &lt;&lt; (foo&amp;=bar) &lt;&lt; &#39;\\n&#39;; // 0010 (AND,assign) cout &lt;&lt; (foo|=bar) &lt;&lt; &#39;\\n&#39;; // 0011 (OR,assign) cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; &#39;\\n&#39;; // 1100 (SHL,assign) cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; &#39;\\n&#39;; // 0110 (SHR,assign) cout &lt;&lt; (~bar) &lt;&lt; &#39;\\n&#39;; // 1100 (NOT) cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; &#39;\\n&#39;; // 0110 (SHL) cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; &#39;\\n&#39;; // 0001 (SHR) cout &lt;&lt; (foo==bar) &lt;&lt; &#39;\\n&#39;; // false (0110==0011) cout &lt;&lt; (foo!=bar) &lt;&lt; &#39;\\n&#39;; // true (0110!=0011) cout &lt;&lt; (foo&amp;bar) &lt;&lt; &#39;\\n&#39;; // 0010 cout &lt;&lt; (foo|bar) &lt;&lt; &#39;\\n&#39;; // 0111 cout &lt;&lt; (foo^bar) &lt;&lt; &#39;\\n&#39;; // 0101 参考资料 C++ Reference CSDN by Inside_Zhang [胡小兔的OI博客](","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://roy1994.top/tags/STL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-07-24T15:14:33.247Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"http://roy1994.top/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://roy1994.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"http://roy1994.top/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"Balance Tree(FHQ Treap)","slug":"Balance-Tree-FHQ-Treap","date":"2018-08-13T05:00:42.000Z","updated":"2021-07-24T15:14:36.109Z","comments":true,"path":"2018/08/13/Balance-Tree-FHQ-Treap/","link":"","permalink":"http://roy1994.top/2018/08/13/Balance-Tree-FHQ-Treap/","excerpt":"","text":"听说这个平衡树很好写，所以我尝试去学一下这个毒瘤的数据结构 FHQ Treap简介FHQ Treap只有两种主要的操作 分离（split） 把一棵树分成两个树 合并（merge） 把两棵树合成一棵树 通过 分离 和 合并 的操作，FHQ Treap可以完成普通平衡树的很多操作 插入 删除 查询排名为 $i$ 的数 查询 $wei$ 的排名 求 $wei$ 的前驱 求 $wei$ 的后继 反转区间 树的节点FHQ Treap 的节点维护的 普通Treap 维护的大致相同，我们通过一个结构体来保存信息相关含义如下： size —&gt; 子树（包括自身）的大小 val —&gt; 该节点的值 rnd —&gt; Treap中用于堆的随机值 l r —&gt; 左节点和右节点 下面给出代码： struct FHQ { int size,val,rnd; }tr[N]; 操作 1 : 插入按照普通treap的写法，我们需要新建一个节点，需要调用newnode函数 int tot=0; int newnode(int v) { tr[++tot].size=1;tr[tot].val=v,tr[tot].rnd=rand(); return tot;//返回新节点的编号 } 我们可以把原来的数按新节点的值分成两份，再依次合并，就完成了插入的过程 void ins(int wei) { int x,y; spilt(root,wei,x,y); //root表示目前总树的根节点 //把总树分成以x,y为根节点的两棵树 root=merge(merge(x,newnode(wei)),y); //合并所有子树并重置根节点 } 操作 2 ： 删除删除权值为 $wei$ 的点，先把整颗树以 $wei$ 为权值 $split$ 成两棵树 $x$，$y$，再把 $x$ 树按照 $wei-1$ 分成 $p$，$q$。 这时候值为wei的点一定为 $q$ 的根，那么我们把 $q$ 的两个子儿子 $merge$ 起来（这一步就是去除掉 $wei$ 的影响），再把他们重新 $merge$ 起来得到一个新的树，这颗树就去除掉了 $wei$ 的影响。 void del(int wei) { int x,int y,int p,int q; spilt(root,wei,x,y); split(x,wei-1,p,q); q=merge(tr[q].l,tr[q].r); root=merge(merge(p,q),y); } 操作 3 ： 查询排名为 i 的数和普通Treap是一样的， 但注意，这个函数返回的是 排名为 i 的数 的节点编号k（值为tr[k].val） 。 int getNum(int now,int rk) { while(1) { if(rk&lt;=tr[tr[now].l].size) now=tr[now].l; else { if(rk==tr[tr[now].l].size+1) return now; else { rk-=tr[re[now].l].size+1; now=tr[now].r; } } } } 操作 4 ： 查询 wei 的排名把总树按 $wei$ 进行 $spilt$ ，得到左部分树的大小即为rank值。 int getRank(int wei) { int x,y; spilt(root,wei,x,y); return tr[x].size; } 操作 5 ： 求 wei 的前驱把总树按 $wei-1$ 分成两份，所以小于 $wei$ 的节点都在左部分树中，只需要求出左部分树的size所对应的节点的值，就是所求的 $wei$ 的前驱。 int pre(int wei) { int x,y; spilt(root,wei-1,x,y); return tr[getNum(x,tr[x].size)].val; root=merge(x,y);//回复原状 } 操作 6 ： 求 wei 的后继找后继是相同的，把总树按 $wei$ 为权值调用 $split$，此时右部分树排名第一的数就是后继 int suc(int wei) { int x,y; spilt(root,wei+1,x,y); return tr[getNum(y,1)].val; root=merge(x,y);//回复原状 } 操作 7 ： 反转区间先咕着，有空补 核心 1： merge 操作$merge$ 操作即按照 FHQ Treap 的附加权值玄学维持平衡并进行合并 int merge(int x,int y)//x 恒&lt; y ,所以需要保证顺序 { if(!x||!y) return x+y; update(x),update(y); if(tr[x].rnd&lt;tr[y].rnd) { tr[x].r=merge(tr[x].r,y); update(x); return x; } else { tr[y].l=merge(x,tr[y].l); update(y); return y; } } 核心 2： spilt 操作$split$ 是把一颗Treap分开两个树的操作。 有两种分法，一种是按权值分，一种是按$size$（子树大小）分，具体用哪个要看情况。 按权值分 注意这时候权值小于等于 k的节点都在左树中，大于 k的都在右树中 ： void spilt(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(val&lt;=tr[tr[now].l].val) y=now,spilt(tr[now].l,val,x,tr[now].l); else x=now,spilt(tr[now].r,val,tr[now].r,y); update(now); } } 按 $size$ 分 ： void spilt(int now,int rnk,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(rnk&lt;=tr[tr[now].l].size) y=now,spilt(tr[now].l,rnk,x,tr[now].l); else x=now,spilt(tr[now].r,rnk-tr[tr[now].l].size-1,tr[now].r,y); update(now); } } END","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://roy1994.top/tags/algorithm/"},{"name":"平衡树","slug":"平衡树","permalink":"http://roy1994.top/tags/平衡树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]},{"title":"Git","slug":"git","date":"2018-08-13T05:00:42.000Z","updated":"2021-12-03T05:14:20.642Z","comments":true,"path":"2018/08/13/git/","link":"","permalink":"http://roy1994.top/2018/08/13/git/","excerpt":"","text":"使用基本设置ssh 配置 ssh-keygen -t rsa -C &quot;YourEmail@email.com&quot; \\r\\r\\r ... seek for &quot;.ssh&quot; in the user file copy &quot;id_rsa.pub&quot; 提交代码时的用户信息 git config --global user.name &quot;YourUsername&quot; git config --global user.email &quot;YourEmail@email.com&quot; 初始仓库初始化 git init 指定目录 dir git &lt;dir&gt; 常用操作跟踪文件/加入暂存区 git add * git add README git add *.c 加入本地仓库 git commit -m &quot;First&quot; //windows git commit -m &#39;First&#39; //linux 克隆仓库 git clone &lt;repo&gt; 基本操作查看仓库当前状态git status 回退版本 git reset HEAD^ // 回退所有内容到上一个版本 git reset HEAD^ hello.php // 回退 hello.php 文件的版本到上一个版本 git reset 052e // 回退到指定版本 git reset --soft HEAD~3 // 回退上上上一个版本 HEAD~0 表示当前版本 HEAD~1 上一个版本 HEAD^2 上上一个版本 HEAD^3 上上上一个版本 比较文件的不同 git diff 远程操作添加一个新的远程仓库 git remote add [shortname] [url] git remote add origin https://github.com/MoveCloudROY/cdn.git 显示所有远程仓库 git remote -v 从远程获取代码库 git fetch [alias] //获取远端的更新 git merge [alias]/[branch] //将服务器上的任何更新合并到你的当前分支 alias - 本地仓库 branch - 远程仓库 分支管理创建分支 git branch (branchname) 切换分支 git checkout (branchname) ​ - 创造并切换 git checkout -b change_site 列出分支 git branch 删除分支 git branch -d (branchname) 分支合并 git merge (branchname) //合并 branch 到主分支","categories":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}],"tags":[{"name":"git","slug":"git","permalink":"http://roy1994.top/tags/git/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://roy1994.top/categories/技术/"}]}]}